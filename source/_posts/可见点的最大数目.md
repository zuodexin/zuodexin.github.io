
#### 

二分查找，注意atan2的输入和输出，upper_bound的使用

```c++
class Solution {
public:
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        if(points.size()==0){
            return 0;
        }
        vector<double> polars;
        int overlap=0;
        int num_ext = 0;
        for(int i=0;i<points.size();i++){
            vector<int> point=points[i];
            int x = point[0],y=point[1];
            if((location[0]==x) && (location[1]==y) ){
                overlap++;
            }else{
                double theta = atan2(x-location[0],y-location[1]);
                polars.push_back(theta);
                polars.push_back(theta+2*M_PI);
                num_ext++;
            }
        }
        sort(polars.begin(),polars.end());
        int max_num = 0;
        for(int i=0;i<polars.size()-num_ext;i++){
            int up_idx = upper_bound(polars.begin()+i,polars.end(), polars[i]+angle*M_PI/180)-polars.begin();
            max_num = max(max_num,up_idx-i);
        }
        max_num += overlap;
        return max_num;
    }
};
```