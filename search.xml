<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>N皇后</title>
    <url>/2020/11/08/N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>阅读全文查看代码<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">queen_col</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        helper(n, <span class="number">0</span>, res, queen_col);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">queen_col</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        helper(n, <span class="number">0</span>, res, queen_col);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queen_col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == r) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">solution</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queen_col.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                solution[i][queen_col[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(solution);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_valid(r, i, queen_col)) &#123;</span><br><span class="line">                queen_col[r] = i;</span><br><span class="line">                helper(n, r + <span class="number">1</span>, res, queen_col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queen_col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == queen_col[i] || <span class="built_in">abs</span>(r - i) == <span class="built_in">abs</span>(c - queen_col[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>attention机制原理与应用</title>
    <url>/2020/11/08/attention%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>待完成<br><a id="more"></a></p>
]]></content>
      <tags>
        <tag>NLP</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode205同构字符串</title>
    <url>/2020/11/08/leetcode205%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>做这道题要先理解什么是同构字符串，以及字符的替换规则</p>
<p>用两个unordered_map来保存映射关系</p>
<p>注意maker_pair中的类型为引用类型<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; replaced;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; reversed; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(replaced.<span class="built_in">find</span>(s[i])!=replaced.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(replaced[s[i]]!=t[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(reversed.<span class="built_in">find</span>(t[i])!=reversed.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    replaced.insert(<span class="built_in">std</span>::make_pair&lt;<span class="keyword">char</span>&amp;,<span class="keyword">char</span>&amp;&gt;(s[i],t[i]));</span><br><span class="line">                    reversed.insert(<span class="built_in">std</span>::make_pair&lt;<span class="keyword">char</span>&amp;,<span class="keyword">char</span>&amp;&gt;(t[i],s[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《强化学习》要点梳理</title>
    <url>/2020/11/08/%E3%80%8A%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>待完成<br><a id="more"></a></p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉slam14讲》要点梳理</title>
    <url>/2020/11/08/%E3%80%8A%E8%A7%86%E8%A7%89slam14%E8%AE%B2%E3%80%8B%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>待完成<br><a id="more"></a></p>
]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>区间和</title>
    <url>/2020/11/08/%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<p>要用到线段树这个数据结构</p>
<p>主要的方法有：建树，更新，区间和，都可以使用递归来实现。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> arr[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">            build_tree(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update_helper(i, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            nums[i] = val;</span><br><span class="line">            arr[node] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">            update_helper(i, l, mid, val, left_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update_helper(i, mid + <span class="number">1</span>, r, val, right_node);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[node] = arr[left_node] + arr[right_node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sumRangeHelper(i,j,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRangeHelper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r||(i==l)&amp;&amp;(j==r))&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, j, l, mid, left_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, j, mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, mid, l, mid, left_node) +</span><br><span class="line">                   sumRangeHelper(mid+<span class="number">1</span>, j, mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            arr[node] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        build_tree(l, mid, left_node);</span><br><span class="line">        build_tree(mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        arr[node] = arr[left_node] + arr[right_node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>和为K的最短子数组</title>
    <url>/2020/11/08/%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>阅读全文查看代码<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;,</span><br><span class="line">                       greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;</span><br><span class="line">            pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k) ans = <span class="built_in">min</span>(ans, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.empty() &amp;&amp; sum - pq.top().first &gt;= k) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, i - pq.top().second);</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            pq.push(make_pair(sum, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>奇思妙想合集</title>
    <url>/2020/11/08/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>热量摄入过多会发胖，信息摄入过多会变秃 ​​​</li>
</ul>
<ul>
<li><p>在程序里试图通过细粒度的日志来记录运行时间，但同时io的时间也影响到了测量结果，我称之为“测不准原理” ​​​</p>
<a id="more"></a>
</li>
<li><p>da ja vu在一些搞笑视频的弹幕里经常被戏称为“逮虾户”，这个词实际上描述的是一种对于事情或场景似曾相识的感觉，开个脑洞解释一下这种现象：人的的未来有无数种可能性，而人的思维有固有的频率，现在的思维和平行宇宙中未来某个分支上的思维发生了共振。<br>人类演化到现在保留了这种能力，原因是它能帮人类做出正确的选择，当人对某些选项有旧识感的时候或许与未来的自己完成了某种信息交换，然后潜意识通过直觉告诉自己怎样做出选择.</p>
</li>
</ul>
<ul>
<li>人在吃方面应该是最容易发生共情的吧，比如你听别人的歌单就像把耳机插进垃圾桶一样，大多数你觉得好吃的东西，你周围的人通常不会觉得难以下咽 ​​​</li>
</ul>
<ul>
<li>发朋友圈不带屏蔽就跟你走上舞台上表演一样,一不注意就是灾难艺术</li>
</ul>
<ul>
<li>心跳是心脏细胞协同跳动的结果，每个细胞的周期和相位都有差别，体内有一套神奇的机制让他们同步，不健康的生活方式会损害细胞的同步机制，细胞跳动乱套了，宏观上不能构成心跳，更严重的是这种混乱是正反馈系统，因此发作起来非常迅速，严重的会猝死</li>
</ul>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>数学问题--求到空间内到n条直线距离和最小的点</title>
    <url>/2020/07/26/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98-%E6%B1%82%E5%88%B0%E7%A9%BA%E9%97%B4%E5%86%85%E5%88%B0n%E6%9D%A1%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h1><span id="背景">背景</span></h1><p>这个问题起源于多视角几何里面的三角化问题。已知n个视角的相机参数，和某一关键点在每个视角下的投影，如何计算这个关键点的三维坐标。粗略地想，连接投影在图片上的关键点和相机光心可以获得一条直线，n个视角可以获得n条这样的直线，求交点即可求得3D坐标。不过，在现实当中，关键点的投影总是存在扰动，这n条直线不可能完美地交于一个点，那么这种情况如何计算3D坐标呢？<br><a id="more"></a></p>
<p>常用的方法是根据几何共线关系建立方程组，这个方程组通常是超定方程，那么可以用最小二乘法求解。最小二乘一般有两种，一种是伪逆法，一种是SVD分解，伪逆法对应的条件数比SVD分解对应的条件数大，矩阵更加病态，数值上不稳定，所以一般SVD分解会更好一些。</p>
<h1><span id="猜想">猜想</span></h1><p>从几何上看，求上述方程组的最小二乘解似乎是在找一个点，要求它到n条直线的距离之和最小，那么存不存在这样的点呢，这样的点有多少个？</p>
<h1><span id="最小值存在性">最小值存在性</span></h1><p>首先需要对问题进行建模，直线的表示方法有解析式和向量形式，为了避免解析形式除法运算，这里使用向量形式。直线的向量形式为<br>$\mathcal{L}(t)=P+t\vec{d}$<br>P是直线上的一点，$\vec{d}$是单位矢量，设Q为直线外的一点，Q到$\mathcal{L}$的距离为<br>$d = ||\overrightarrow{PQ}-t_0\vec{d}||$<br>其中$t_0=\vec{d}\cdot\overrightarrow{PQ}$<br>定义函数$\mathcal{S}(Q)$为Q到n条直线的距离和</p>
<p>$\mathcal{S}({Q})=\sum_i^{n}{d_i}=\sum_i^{n}{||\overrightarrow{P_iQ}-t_0\vec{d_i}||}$<br>假设$Q_1,Q_2$是空间内任意两点，</p>
<script type="math/tex; mode=display">\frac{1}{2}(\mathcal{S}(Q_1)+\mathcal{S}(Q_2))=\frac{1}{2}\sum_i^{n}{(||\overrightarrow{P_iQ_1}-t_1\vec{d_i}||+||\overrightarrow{P_iQ_2}-t_2\vec{d_i}||})

\geq\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-\frac{t_1+t_2}{2}\vec{d_i}||}

=\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-<\vec{d_i},\overrightarrow{P_i\frac{Q_1+Q_2}{2}}>\vec{d_i}||}

=\mathcal{S}(\frac{Q_1+Q_2}{2})</script><p>$\mathcal{S}(Q)$是凸函数，最多只有一个最小值，因此除去一些特殊情况（直线重合、平行），一般在空间里只存在一个点使得这个点到给定n条直线的距离最小。</p>
<h1><span id="最小值求法">最小值求法</span></h1><p>从直觉上，最小值就是三角化里用最小二乘法得到的方程组的解。方程组的约束是共线约束，而这里是让点到直线的距离最小，其实共线和距离最小其实是等价的，如何证明呢？还得用上叉乘的几何意义。给定一个点$P$，让P、Q和$P+t\vec{d}$共线等价于最小化$\vec{d}\times\overrightarrow{PQ}$，等价于最小化$\vec{d}$和$\overrightarrow{PQ}$组成的平行四边形的面积，等价于最小化Q到直线的距离。</p>
<h2><span id="三角化的求解方式">三角化的求解方式</span></h2><p>设三位空间点的世界坐标为$\mathbf{X}=[x,y,z,1]^T$,归一化平面坐标为$\mathbf{x}=[u,v,1]^T$，$\lambda$为深度值，世界坐标到相机坐标的变换为$\mathbf{T}$,相机的成像模型为</p>
<script type="math/tex; mode=display">\lambda \mathbf{x}=\mathbf{TX}

\Rightarrow \lambda \mathbf{x}\times\mathbf{TX} = 0</script><p>叉乘可以借助$\mathbf{x}$对应的反对称矩阵表示出来，上面的式子可以简化为一个超定方程组，求解这个方程组即可。</p>
<h2><span id="程序验证">程序验证</span></h2><p>待完成</p>
]]></content>
      <tags>
        <tag>slam</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>测试Hexo</title>
    <url>/2020/07/26/%E6%B5%8B%E8%AF%95Hexo/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode179组合为最大的数</title>
    <url>/2020/11/09/leetcode179%E7%BB%84%E5%90%88%E4%B8%BA%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>不知道为什么我的答案出现越界错误，改成简单的答案就不会出错了</p>
<p>权当掌握lambda表达式和string的比较罢了，有空再看</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    ss&lt;&lt;i;</span><br><span class="line">    ss&gt;&gt;s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sa,sb;</span><br><span class="line">    sa = int2string(a);</span><br><span class="line">    sb = int2string(b);</span><br><span class="line">    <span class="keyword">return</span> sa+sb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_le</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[i]==<span class="string">'0'</span> &amp;&amp; i&lt;a.<span class="built_in">size</span>()) i++;</span><br><span class="line">    <span class="keyword">while</span>(b[j]==<span class="string">'0'</span> &amp;&amp; j&lt;b.<span class="built_in">size</span>()) j++;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()-i!=b.<span class="built_in">size</span>()-j) <span class="keyword">return</span> a.<span class="built_in">size</span>()-i&lt;b.<span class="built_in">size</span>()-j;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; j&lt;b.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[i]&lt;b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// return true;</span></span><br><span class="line">    <span class="keyword">return</span> str_le(combine(a,b),combine(b,a));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> (to_string(a)+to_string(b))&lt;(to_string(b)+to_string(a));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">0</span>||nums[i]!=<span class="number">0</span>)</span><br><span class="line">                s += int2string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) s=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_le</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a,<span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; a[i]==<span class="string">'0'</span>) i++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;b.<span class="built_in">size</span>() &amp;&amp; b[j]==<span class="string">'0'</span>) j++;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()-i!=b.<span class="built_in">size</span>()-j) <span class="keyword">return</span> a.<span class="built_in">size</span>()-i&lt;b.<span class="built_in">size</span>()-j;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; j&lt;b.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[i]&lt;b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; ab = to_string(a)+to_string(b);</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; ba = to_string(b)+to_string(a);</span><br><span class="line">                <span class="keyword">return</span> str_le(ab,ba);</span><br><span class="line">            &#125;; </span><br><span class="line">        &#125; obj;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),obj);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">0</span>||nums[i]!=<span class="number">0</span>)</span><br><span class="line">                s += to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) s=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode698拆分k个和相等的子集合</title>
    <url>/2020/11/17/leetcode698%E6%8B%86%E5%88%86k%E4%B8%AA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>回溯法求解</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subsets</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">picked</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> helper(nums,k,subsets,picked,sum/k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;subsets,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;picked,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!picked[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;subsets.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(subsets[j]+nums[i]&lt;=s)&#123;</span><br><span class="line">                        picked[i] = <span class="literal">true</span>;</span><br><span class="line">                        subsets[j] += nums[i];</span><br><span class="line">                        <span class="comment">// printf("nums[%d]:%d subsets[%d]:%d\n",i,nums[i],j,subsets[j]);</span></span><br><span class="line">                        <span class="keyword">if</span>(helper(nums,k,subsets,picked,s))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            picked[i] = <span class="literal">false</span>;</span><br><span class="line">                            subsets[j] -= nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode525相同个数01的最长连续子数组</title>
    <url>/2020/11/17/leetcode525%E7%9B%B8%E5%90%8C%E4%B8%AA%E6%95%B001%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>维护变量count，遇到0减1，遇到1加一，记录遇到count的最早位置，下次遇到后计算长度，<br>画个折线图就能理解为什么这两个位置间的01个数相等。</p>
<p>扩展一下，以后遇到这种相等的可以考虑一下这种折线图的解法。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m.insert(&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count += nums[i]==<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(count)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                maxlen = <span class="built_in">std</span>::<span class="built_in">max</span>(maxlen,i-m[count]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.insert(&#123;count,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode1222能攻击到国王的皇后</title>
    <url>/2020/11/21/leetcode1222%E8%83%BD%E6%94%BB%E5%87%BB%E5%88%B0%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>有多种解法，一种是在地图上以国王为中心在地图上遍历；另一种是遍历皇后数组，更新最过滤掉被挡住的皇后，这种在皇后比较少的情况下更快</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">queensAttacktheKing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queens, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; king)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q_set;</span><br><span class="line">        <span class="keyword">int</span> x_max = king[<span class="number">0</span>],y_max=king[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queens.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            q_set.insert(<span class="built_in">std</span>::make_pair(queens[i][<span class="number">0</span>],queens[i][<span class="number">1</span>]));</span><br><span class="line">            x_max = <span class="built_in">max</span>(x_max,queens[i][<span class="number">0</span>]);</span><br><span class="line">            y_max = <span class="built_in">max</span>(y_max,queens[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; attack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;direction.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta = direction[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">1</span>;;<span class="built_in">step</span>++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = king[<span class="number">0</span>]+delta[<span class="number">0</span>]*<span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">int</span> y = king[<span class="number">1</span>]+delta[<span class="number">1</span>]*<span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;x_max || y&lt;<span class="number">0</span> || y&gt;y_max)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p = <span class="built_in">std</span>::make_pair(x,y);</span><br><span class="line">                <span class="keyword">if</span>(q_set.<span class="built_in">find</span>(p)!=q_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">                    t.push_back(x);</span><br><span class="line">                    t.push_back(y);</span><br><span class="line">                    attack.push_back(t);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode785判断二分图</title>
    <url>/2020/11/21/leetcode785%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<p>这道题可以用dfs、bfs，并查集都可以做，下面的代码用是并查集实现的</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(graph.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++) root[i] =i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="built_in">find</span>(root,i);</span><br><span class="line">            <span class="keyword">int</span> q = <span class="built_in">find</span>(root,graph[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;graph[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="built_in">find</span>(root,graph[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(r==p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> root[graph[i][j]] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root[i]==i? i:<span class="built_in">find</span>(root, root[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>leetcode547朋友圈</title>
    <url>/2020/11/21/leetcode547%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<p>可以用bfs、dfs、和并查集，下面我们用并查集来做，注意：每合并一次朋友圈的数量减1</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = M.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(M.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++) root[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;M.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> rj = <span class="built_in">find</span>(root,j);</span><br><span class="line">                <span class="keyword">int</span> ri = <span class="built_in">find</span>(root,i);</span><br><span class="line">                <span class="keyword">if</span>(rj!=ri)&#123;</span><br><span class="line">                    res--;</span><br><span class="line">                    root[rj] = ri;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root[i]==i?i:<span class="built_in">find</span>(root,root[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并查集优化技巧,查询时缩短深度<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != root[i]) &#123;</span><br><span class="line">            root[i] = root[root[i]];</span><br><span class="line">            i = root[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode863距离为K的所有二叉树节点</title>
    <url>/2020/11/21/leetcode863%E8%B7%9D%E7%A6%BB%E4%B8%BAK%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>需要熟悉二叉树中的距离概念，这道题可以作为一道很好的递归、回溯练习题。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        core(root,target,K,res);</span><br><span class="line">        <span class="comment">// cout&lt;&lt; "****"&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">core</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target-&gt;val)&#123;</span><br><span class="line">            downwardK(target,K,nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">find</span>(root-&gt;right,target)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="built_in">find</span>(root-&gt;left,target)+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"rd: "&lt;&lt; rd &lt;&lt; " ld: "&lt;&lt; ld &lt;&lt;" K: "&lt;&lt;K&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(rd==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(K==ld)&#123;</span><br><span class="line">                nums.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            downwardK(root-&gt;right,K-ld<span class="number">-1</span>,nums);</span><br><span class="line">            core(root-&gt;left,target,K,nums);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ld==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(K==rd)&#123;</span><br><span class="line">                nums.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            downwardK(root-&gt;left,K-rd<span class="number">-1</span>,nums);</span><br><span class="line">            core(root-&gt;right,target,K,nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downwardK</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> || k&lt;<span class="number">0</span> ) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"root "&lt;&lt; root-&gt;val &lt;&lt; "k: "&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            nums.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        downwardK(root-&gt;left,k<span class="number">-1</span>,nums);</span><br><span class="line">        downwardK(root-&gt;right,k<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode* root, TreeNode* target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">find</span>(root-&gt;right,target);</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="built_in">find</span>(root-&gt;left,target);</span><br><span class="line">        <span class="keyword">if</span>(rd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rd+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ld!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ld+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode777交换LR字符串</title>
    <url>/2020/11/21/leetcode777%E4%BA%A4%E6%8D%A2LR%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>看懂题目之后很好理解，变换中L只能往左移动，R只能往右移动，因此用双指针就可以了。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start.<span class="built_in">size</span>()!=<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"i: "&lt;&lt;i&lt;&lt;" j:"&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;start.<span class="built_in">size</span>()&amp;&amp;start[i]==<span class="string">'X'</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;<span class="built_in">end</span>.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">end</span>[j]==<span class="string">'X'</span>) j++;</span><br><span class="line">            <span class="keyword">if</span>(i==start.<span class="built_in">size</span>()||j==<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(start[i]!=<span class="built_in">end</span>[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start[i]==<span class="string">'R'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=j)&#123; </span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start[i]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==start.<span class="built_in">size</span>()&amp;&amp;j==<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode477全部汉明距离</title>
    <url>/2020/11/22/leetcode477%E5%85%A8%E9%83%A8%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>分别统计每一位上0，1的个数，这一位产生的汉明距离就是二者的乘积</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bit</span> = <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">bit</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt_0 = <span class="number">0</span>, cnt_1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[j];</span><br><span class="line">                <span class="keyword">if</span> (num &amp; ( <span class="number">1</span> &lt;&lt; i ))&#123;</span><br><span class="line">                    cnt_1++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt_0++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += cnt_0*cnt_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode494目标总和</title>
    <url>/2020/11/22/leetcode494%E7%9B%AE%E6%A0%87%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>动态规划</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(S)&gt;<span class="number">1000</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">2001</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>+<span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2001</span>;j++)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="built_in">min</span>(j+nums[i],<span class="number">2000</span>)] += dp[i][j];</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="built_in">max</span>(j-nums[i],<span class="number">0</span>)] += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][S+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
