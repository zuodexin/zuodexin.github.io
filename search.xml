<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>数学问题--求到空间内到n条直线距离和最小的点</title>
    <url>/2020/07/26/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98-%E6%B1%82%E5%88%B0%E7%A9%BA%E9%97%B4%E5%86%85%E5%88%B0n%E6%9D%A1%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>这个问题起源于多视角几何里面的三角化问题。已知n个视角的相机参数，和某一关键点在每个视角下的投影，如何计算这个关键点的三维坐标。粗略地想，连接投影在图片上的关键点和相机光心可以获得一条直线，n个视角可以获得n条这样的直线，求交点即可求得3D坐标。不过，在现实当中，关键点的投影总是存在扰动，这n条直线不可能完美地交于一个点，那么这种情况如何计算3D坐标呢？</p>
<p>常用的方法是根据几何共线关系建立方程组，这个方程组通常是超定方程，那么可以用最小二乘法求解。最小二乘一般有两种，一种是伪逆法，一种是SVD分解，伪逆法对应的条件数比SVD分解对应的条件数大，矩阵更加病态，数值上不稳定，所以一般SVD分解会更好一些。</p>
<h1 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h1><p>从几何上看，求上述方程组的最小二乘解似乎是在找一个点，要求它到n条直线的距离之和最小，那么存不存在这样的点呢，这样的点有多少个？</p>
<h1 id="最小值存在性"><a href="#最小值存在性" class="headerlink" title="最小值存在性"></a>最小值存在性</h1><p>首先需要对问题进行建模，直线的表示方法有解析式和向量形式，为了避免解析形式除法运算，这里使用向量形式。直线的向量形式为<br>$\mathcal{L}(t)=P+t\vec{d}$<br>P是直线上的一点，$\vec{d}$是单位矢量，设Q为直线外的一点，Q到$\mathcal{L}$的距离为<br>$d = ||\overrightarrow{PQ}-t_0\vec{d}||$<br>其中$t_0=\vec{d}\cdot\overrightarrow{PQ}$<br>定义函数$\mathcal{S}(Q)$为Q到n条直线的距离和</p>
<p>$\mathcal{S}({Q})=\sum_i^{n}{d_i}=\sum_i^{n}{||\overrightarrow{P_iQ}-t_0\vec{d_i}||}$<br>假设$Q_1,Q_2$是空间内任意两点，</p>
<script type="math/tex; mode=display">\frac{1}{2}(\mathcal{S}(Q_1)+\mathcal{S}(Q_2))=\frac{1}{2}\sum_i^{n}{(||\overrightarrow{P_iQ_1}-t_1\vec{d_i}||+||\overrightarrow{P_iQ_2}-t_2\vec{d_i}||})

\geq\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-\frac{t_1+t_2}{2}\vec{d_i}||}

=\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-<\vec{d_i},\overrightarrow{P_i\frac{Q_1+Q_2}{2}}>\vec{d_i}||}

=\mathcal{S}(\frac{Q_1+Q_2}{2})</script><p>$\mathcal{S}(Q)$是凸函数，最多只有一个最小值，因此除去一些特殊情况（直线重合、平行），一般在空间里只存在一个点使得这个点到给定n条直线的距离最小。</p>
<h1 id="最小值求法"><a href="#最小值求法" class="headerlink" title="最小值求法"></a>最小值求法</h1><p>从直觉上，最小值就是三角化里用最小二乘法得到的方程组的解。方程组的约束是共线约束，而这里是让点到直线的距离最小，其实共线和距离最小其实是等价的，如何证明呢？还得用上叉乘的几何意义。给定一个点$P$，让P、Q和$P+t\vec{d}$共线等价于最小化$\vec{d}\times\overrightarrow{PQ}$，等价于最小化$\vec{d}$和$\overrightarrow{PQ}$组成的平行四边形的面积，等价于最小化Q到直线的距离。</p>
<h2 id="三角化的求解方式"><a href="#三角化的求解方式" class="headerlink" title="三角化的求解方式"></a>三角化的求解方式</h2><p>设三位空间点的世界坐标为$\mathbf{X}=[x,y,z,1]^T$,归一化平面坐标为$\mathbf{x}=[u,v,1]^T$，$\lambda$为深度值，世界坐标到相机坐标的变换为$\mathbf{T}$,相机的成像模型为</p>
<script type="math/tex; mode=display">\lambda \mathbf{x}=\mathbf{TX}

\Rightarrow \lambda \mathbf{x}\times\mathbf{TX} = 0</script><p>叉乘可以借助$\mathbf{x}$对应的反对称矩阵表示出来，上面的式子可以简化为一个超定方程组，求解这个方程组即可。</p>
<h2 id="程序验证"><a href="#程序验证" class="headerlink" title="程序验证"></a>程序验证</h2><p>待完成</p>
]]></content>
  </entry>
  <entry>
    <title>测试Hexo</title>
    <url>/2020/07/26/%E6%B5%8B%E8%AF%95Hexo/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode205同构字符串</title>
    <url>/2020/11/08/leetcode205%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>做这道题要先理解什么是同构字符串，以及字符的替换规则</p>
<p>用两个unordered_map来保存映射关系</p>
<p>注意maker_pair中的类型为引用类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        if(s.length()!&#x3D;t.length())&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if(s.length()&#x3D;&#x3D;0) return true;</span><br><span class="line">        unordered_map&lt;char,char&gt; replaced;</span><br><span class="line">        unordered_map&lt;char,char&gt; reversed; </span><br><span class="line">        for(int i&#x3D;0;i&lt;s.length();i++)&#123;</span><br><span class="line">            if(replaced.find(s[i])!&#x3D;replaced.end())&#123;</span><br><span class="line">                if(replaced[s[i]]!&#x3D;t[i])&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(reversed.find(t[i])!&#x3D;reversed.end())&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    replaced.insert(std::make_pair&lt;char&amp;,char&amp;&gt;(s[i],t[i]));</span><br><span class="line">                    reversed.insert(std::make_pair&lt;char&amp;,char&amp;&gt;(t[i],s[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
