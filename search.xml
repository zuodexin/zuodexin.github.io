<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>N皇后</title>
    <url>/2020/11/08/N%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>阅读全文查看代码<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; <span class="title">solveNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">queen_col</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        helper(n, <span class="number">0</span>, res, queen_col);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalNQueens</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">queen_col</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        helper(n, <span class="number">0</span>, res, queen_col);</span><br><span class="line">        <span class="keyword">return</span> res.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; &amp;res,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queen_col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == r) &#123;</span><br><span class="line">            <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">solution</span><span class="params">(n, <span class="built_in">string</span>(n, <span class="string">'.'</span>))</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; queen_col.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">                solution[i][queen_col[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(solution);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is_valid(r, i, queen_col)) &#123;</span><br><span class="line">                queen_col[r] = i;</span><br><span class="line">                helper(n, r + <span class="number">1</span>, res, queen_col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">is_valid</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; queen_col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == queen_col[i] || <span class="built_in">abs</span>(r - i) == <span class="built_in">abs</span>(c - queen_col[i]))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title>attention机制原理与应用</title>
    <url>/2020/11/08/attention%E6%9C%BA%E5%88%B6%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<p>待完成<br><a id="more"></a></p>
]]></content>
      <tags>
        <tag>NLP</tag>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/26/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode205同构字符串</title>
    <url>/2020/11/08/leetcode205%E5%90%8C%E6%9E%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>做这道题要先理解什么是同构字符串，以及字符的替换规则</p>
<p>用两个unordered_map来保存映射关系</p>
<p>注意maker_pair中的类型为引用类型<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length()!=t.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; replaced;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">char</span>&gt; reversed; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(replaced.<span class="built_in">find</span>(s[i])!=replaced.<span class="built_in">end</span>())&#123;</span><br><span class="line">                <span class="keyword">if</span>(replaced[s[i]]!=t[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(reversed.<span class="built_in">find</span>(t[i])!=reversed.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    replaced.insert(<span class="built_in">std</span>::make_pair&lt;<span class="keyword">char</span>&amp;,<span class="keyword">char</span>&amp;&gt;(s[i],t[i]));</span><br><span class="line">                    reversed.insert(<span class="built_in">std</span>::make_pair&lt;<span class="keyword">char</span>&amp;,<span class="keyword">char</span>&amp;&gt;(t[i],s[i]));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>《强化学习》要点梳理</title>
    <url>/2020/11/08/%E3%80%8A%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E3%80%8B%E8%A6%81%E7%82%B9%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<p>待完成<br><a id="more"></a></p>
]]></content>
      <tags>
        <tag>RL</tag>
      </tags>
  </entry>
  <entry>
    <title>区间和</title>
    <url>/2020/11/08/%E5%8C%BA%E9%97%B4%E5%92%8C/</url>
    <content><![CDATA[<p>要用到线段树这个数据结构</p>
<p>主要的方法有：建树，更新，区间和，都可以使用递归来实现。<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">int</span> arr[MAX_LEN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;nums = nums;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&gt;<span class="number">0</span>)</span><br><span class="line">            build_tree(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        update_helper(i, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, val, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update_helper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> val, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            nums[i] = val;</span><br><span class="line">            arr[node] = val;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= mid) &#123;</span><br><span class="line">            update_helper(i, l, mid, val, left_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            update_helper(i, mid + <span class="number">1</span>, r, val, right_node);</span><br><span class="line">        &#125;</span><br><span class="line">        arr[node] = arr[left_node] + arr[right_node];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> sumRangeHelper(i,j,<span class="number">0</span>,nums.<span class="built_in">size</span>()<span class="number">-1</span>,<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRangeHelper</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l==r||(i==l)&amp;&amp;(j==r))&#123;</span><br><span class="line">            <span class="keyword">return</span> arr[node];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt;= mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, j, l, mid, left_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, j, mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> sumRangeHelper(i, mid, l, mid, left_node) +</span><br><span class="line">                   sumRangeHelper(mid+<span class="number">1</span>, j, mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            arr[node] = nums[l];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> left_node = (node + <span class="number">1</span>) * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right_node = (node + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        build_tree(l, mid, left_node);</span><br><span class="line">        build_tree(mid + <span class="number">1</span>, r, right_node);</span><br><span class="line">        arr[node] = arr[left_node] + arr[right_node];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>和为K的最短子数组</title>
    <url>/2020/11/08/%E5%92%8C%E4%B8%BAK%E7%9A%84%E6%9C%80%E7%9F%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>阅读全文查看代码<br><a id="more"></a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestSubarray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;,</span><br><span class="line">                       greater&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;&gt;</span><br><span class="line">            pq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= k) ans = <span class="built_in">min</span>(ans, i + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">while</span> (!pq.empty() &amp;&amp; sum - pq.top().first &gt;= k) &#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, i - pq.top().second);</span><br><span class="line">                pq.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            pq.push(make_pair(sum, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (ans == INT_MAX) ? <span class="number">-1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>奇思妙想合集</title>
    <url>/2020/11/08/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3%E5%90%88%E9%9B%86/</url>
    <content><![CDATA[<ul>
<li>热量摄入过多会发胖，信息摄入过多会变秃 ​​​</li>
</ul>
<ul>
<li><p>在程序里试图通过细粒度的日志来记录运行时间，但同时io的时间也影响到了测量结果，我称之为“测不准原理” ​​​</p>
<a id="more"></a>
</li>
<li><p>da ja vu在一些搞笑视频的弹幕里经常被戏称为“逮虾户”，这个词实际上描述的是一种对于事情或场景似曾相识的感觉，开个脑洞解释一下这种现象：人的的未来有无数种可能性，而人的思维有固有的频率，现在的思维和平行宇宙中未来某个分支上的思维发生了共振。<br>人类演化到现在保留了这种能力，原因是它能帮人类做出正确的选择，当人对某些选项有旧识感的时候或许与未来的自己完成了某种信息交换，然后潜意识通过直觉告诉自己怎样做出选择.</p>
</li>
</ul>
<ul>
<li>人在吃方面应该是最容易发生共情的吧，比如你听别人的歌单就像把耳机插进垃圾桶一样，大多数你觉得好吃的东西，你周围的人通常不会觉得难以下咽 ​​​</li>
</ul>
<ul>
<li>发朋友圈不带屏蔽就跟你走上舞台上表演一样,一不注意就是灾难艺术</li>
</ul>
<ul>
<li>心跳是心脏细胞协同跳动的结果，每个细胞的周期和相位都有差别，体内有一套神奇的机制让他们同步，不健康的生活方式会损害细胞的同步机制，细胞跳动乱套了，宏观上不能构成心跳，更严重的是这种混乱是正反馈系统，因此发作起来非常迅速，严重的会猝死</li>
</ul>
]]></content>
      <tags>
        <tag>奇思妙想</tag>
      </tags>
  </entry>
  <entry>
    <title>数学问题--求到空间内到n条直线距离和最小的点</title>
    <url>/2020/07/26/%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98-%E6%B1%82%E5%88%B0%E7%A9%BA%E9%97%B4%E5%86%85%E5%88%B0n%E6%9D%A1%E7%9B%B4%E7%BA%BF%E8%B7%9D%E7%A6%BB%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E7%82%B9/</url>
    <content><![CDATA[<h1><span id="背景">背景</span></h1><p>这个问题起源于多视角几何里面的三角化问题。已知n个视角的相机参数，和某一关键点在每个视角下的投影，如何计算这个关键点的三维坐标。粗略地想，连接投影在图片上的关键点和相机光心可以获得一条直线，n个视角可以获得n条这样的直线，求交点即可求得3D坐标。不过，在现实当中，关键点的投影总是存在扰动，这n条直线不可能完美地交于一个点，那么这种情况如何计算3D坐标呢？<br><a id="more"></a></p>
<p>常用的方法是根据几何共线关系建立方程组，这个方程组通常是超定方程，那么可以用最小二乘法求解。最小二乘一般有两种，一种是伪逆法，一种是SVD分解，伪逆法对应的条件数比SVD分解对应的条件数大，矩阵更加病态，数值上不稳定，所以一般SVD分解会更好一些。</p>
<h1><span id="猜想">猜想</span></h1><p>从几何上看，求上述方程组的最小二乘解似乎是在找一个点，要求它到n条直线的距离之和最小，那么存不存在这样的点呢，这样的点有多少个？</p>
<h1><span id="最小值存在性">最小值存在性</span></h1><p>首先需要对问题进行建模，直线的表示方法有解析式和向量形式，为了避免解析形式除法运算，这里使用向量形式。直线的向量形式为<br>$\mathcal{L}(t)=P+t\vec{d}$<br>P是直线上的一点，$\vec{d}$是单位矢量，设Q为直线外的一点，Q到$\mathcal{L}$的距离为<br>$d = ||\overrightarrow{PQ}-t_0\vec{d}||$<br>其中$t_0=\vec{d}\cdot\overrightarrow{PQ}$<br>定义函数$\mathcal{S}(Q)$为Q到n条直线的距离和</p>
<p>$\mathcal{S}({Q})=\sum_i^{n}{d_i}=\sum_i^{n}{||\overrightarrow{P_iQ}-t_0\vec{d_i}||}$<br>假设$Q_1,Q_2$是空间内任意两点，</p>
<script type="math/tex; mode=display">\frac{1}{2}(\mathcal{S}(Q_1)+\mathcal{S}(Q_2))=\frac{1}{2}\sum_i^{n}{(||\overrightarrow{P_iQ_1}-t_1\vec{d_i}||+||\overrightarrow{P_iQ_2}-t_2\vec{d_i}||})

\geq\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-\frac{t_1+t_2}{2}\vec{d_i}||}

=\sum_i^{n}{||\overrightarrow{P_i\frac{Q_1+Q_2}{2}}-<\vec{d_i},\overrightarrow{P_i\frac{Q_1+Q_2}{2}}>\vec{d_i}||}

=\mathcal{S}(\frac{Q_1+Q_2}{2})</script><p>$\mathcal{S}(Q)$是凸函数，最多只有一个最小值，因此除去一些特殊情况（直线重合、平行），一般在空间里只存在一个点使得这个点到给定n条直线的距离最小。</p>
<h1><span id="最小值求法">最小值求法</span></h1><p>从直觉上，最小值就是三角化里用最小二乘法得到的方程组的解。方程组的约束是共线约束，而这里是让点到直线的距离最小，其实共线和距离最小其实是等价的，如何证明呢？还得用上叉乘的几何意义。给定一个点$P$，让P、Q和$P+t\vec{d}$共线等价于最小化$\vec{d}\times\overrightarrow{PQ}$，等价于最小化$\vec{d}$和$\overrightarrow{PQ}$组成的平行四边形的面积，等价于最小化Q到直线的距离。</p>
<h2><span id="三角化的求解方式">三角化的求解方式</span></h2><p>设三位空间点的世界坐标为$\mathbf{X}=[x,y,z,1]^T$,归一化平面坐标为$\mathbf{x}=[u,v,1]^T$，$\lambda$为深度值，世界坐标到相机坐标的变换为$\mathbf{T}$,相机的成像模型为</p>
<script type="math/tex; mode=display">\lambda \mathbf{x}=\mathbf{TX}

\Rightarrow \lambda \mathbf{x}\times\mathbf{TX} = 0</script><p>叉乘可以借助$\mathbf{x}$对应的反对称矩阵表示出来，上面的式子可以简化为一个超定方程组，求解这个方程组即可。</p>
<h2><span id="程序验证">程序验证</span></h2><p>待完成</p>
]]></content>
      <tags>
        <tag>slam</tag>
        <tag>cv</tag>
      </tags>
  </entry>
  <entry>
    <title>测试Hexo</title>
    <url>/2020/07/26/%E6%B5%8B%E8%AF%95Hexo/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>leetcode179组合为最大的数</title>
    <url>/2020/11/09/leetcode179%E7%BB%84%E5%90%88%E4%B8%BA%E6%9C%80%E5%A4%A7%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<p>不知道为什么我的答案出现越界错误，改成简单的答案就不会出错了</p>
<p>权当掌握lambda表达式和string的比较罢了，有空再看</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">int2string</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    ss&lt;&lt;i;</span><br><span class="line">    ss&gt;&gt;s;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">combine</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> sa,sb;</span><br><span class="line">    sa = int2string(a);</span><br><span class="line">    sb = int2string(b);</span><br><span class="line">    <span class="keyword">return</span> sa+sb;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_le</span><span class="params">(<span class="built_in">string</span> a,<span class="built_in">string</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(a[i]==<span class="string">'0'</span> &amp;&amp; i&lt;a.<span class="built_in">size</span>()) i++;</span><br><span class="line">    <span class="keyword">while</span>(b[j]==<span class="string">'0'</span> &amp;&amp; j&lt;b.<span class="built_in">size</span>()) j++;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()-i!=b.<span class="built_in">size</span>()-j) <span class="keyword">return</span> a.<span class="built_in">size</span>()-i&lt;b.<span class="built_in">size</span>()-j;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; j&lt;b.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[i]&lt;b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">less_than</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="comment">// return true;</span></span><br><span class="line">    <span class="keyword">return</span> str_le(combine(a,b),combine(b,a));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;</span><br><span class="line">            <span class="keyword">return</span> (to_string(a)+to_string(b))&lt;(to_string(b)+to_string(a));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">0</span>||nums[i]!=<span class="number">0</span>)</span><br><span class="line">                s += int2string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) s=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">str_le</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; a,<span class="keyword">const</span> <span class="built_in">string</span>&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; a[i]==<span class="string">'0'</span>) i++;</span><br><span class="line">    <span class="keyword">while</span>(j&lt;b.<span class="built_in">size</span>() &amp;&amp; b[j]==<span class="string">'0'</span>) j++;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()-i!=b.<span class="built_in">size</span>()-j) <span class="keyword">return</span> a.<span class="built_in">size</span>()-i&lt;b.<span class="built_in">size</span>()-j;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;a.<span class="built_in">size</span>() &amp;&amp; j&lt;b.<span class="built_in">size</span>() )&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> a[i]&lt;b[j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>&amp; a,<span class="keyword">int</span>&amp; b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; ab = to_string(a)+to_string(b);</span><br><span class="line">                <span class="keyword">const</span> <span class="built_in">string</span>&amp; ba = to_string(b)+to_string(a);</span><br><span class="line">                <span class="keyword">return</span> str_le(ab,ba);</span><br><span class="line">            &#125;; </span><br><span class="line">        &#125; obj;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),obj);</span><br><span class="line">        <span class="built_in">string</span> s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">size</span>()&gt;<span class="number">0</span>||nums[i]!=<span class="number">0</span>)</span><br><span class="line">                s += to_string(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) s=<span class="string">"0"</span>;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode698拆分k个和相等的子集合</title>
    <url>/2020/11/17/leetcode698%E6%8B%86%E5%88%86k%E4%B8%AA%E5%92%8C%E7%9B%B8%E7%AD%89%E7%9A%84%E5%AD%90%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>回溯法求解</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canPartitionKSubsets</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>()&lt;k)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum%k!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subsets</span><span class="params">(k,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">picked</span><span class="params">(nums.<span class="built_in">size</span>(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::sort(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>(),<span class="built_in">std</span>::greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="keyword">return</span> helper(nums,k,subsets,picked,sum/k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;subsets,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp;picked,<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!picked[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;subsets.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(subsets[j]+nums[i]&lt;=s)&#123;</span><br><span class="line">                        picked[i] = <span class="literal">true</span>;</span><br><span class="line">                        subsets[j] += nums[i];</span><br><span class="line">                        <span class="comment">// printf("nums[%d]:%d subsets[%d]:%d\n",i,nums[i],j,subsets[j]);</span></span><br><span class="line">                        <span class="keyword">if</span>(helper(nums,k,subsets,picked,s))</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">else</span>&#123;</span><br><span class="line">                            picked[i] = <span class="literal">false</span>;</span><br><span class="line">                            subsets[j] -= nums[i];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode525相同个数01的最长连续子数组</title>
    <url>/2020/11/17/leetcode525%E7%9B%B8%E5%90%8C%E4%B8%AA%E6%95%B001%E7%9A%84%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>维护变量count，遇到0减1，遇到1加一，记录遇到count的最早位置，下次遇到后计算长度，<br>画个折线图就能理解为什么这两个位置间的01个数相等。</p>
<p>扩展一下，以后遇到这种相等的可以考虑一下这种折线图的解法。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        m.insert(&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            count += nums[i]==<span class="number">1</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(count)!=m.<span class="built_in">end</span>())&#123;</span><br><span class="line">                maxlen = <span class="built_in">std</span>::<span class="built_in">max</span>(maxlen,i-m[count]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                m.insert(&#123;count,i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode1222能攻击到国王的皇后</title>
    <url>/2020/11/21/leetcode1222%E8%83%BD%E6%94%BB%E5%87%BB%E5%88%B0%E5%9B%BD%E7%8E%8B%E7%9A%84%E7%9A%87%E5%90%8E/</url>
    <content><![CDATA[<p>有多种解法，一种是在地图上以国王为中心在地图上遍历；另一种是遍历皇后数组，更新最过滤掉被挡住的皇后，这种在皇后比较少的情况下更快</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">queensAttacktheKing</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; queens, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; king)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; direction = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">-1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q_set;</span><br><span class="line">        <span class="keyword">int</span> x_max = king[<span class="number">0</span>],y_max=king[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;queens.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            q_set.insert(<span class="built_in">std</span>::make_pair(queens[i][<span class="number">0</span>],queens[i][<span class="number">1</span>]));</span><br><span class="line">            x_max = <span class="built_in">max</span>(x_max,queens[i][<span class="number">0</span>]);</span><br><span class="line">            y_max = <span class="built_in">max</span>(y_max,queens[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; attack;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;direction.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; delta = direction[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">1</span>;;<span class="built_in">step</span>++)&#123;</span><br><span class="line">                <span class="keyword">int</span> x = king[<span class="number">0</span>]+delta[<span class="number">0</span>]*<span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">int</span> y = king[<span class="number">1</span>]+delta[<span class="number">1</span>]*<span class="built_in">step</span>;</span><br><span class="line">                <span class="keyword">if</span>(x&lt;<span class="number">0</span> || x&gt;x_max || y&lt;<span class="number">0</span> || y&gt;y_max)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; p = <span class="built_in">std</span>::make_pair(x,y);</span><br><span class="line">                <span class="keyword">if</span>(q_set.<span class="built_in">find</span>(p)!=q_set.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;</span><br><span class="line">                    t.push_back(x);</span><br><span class="line">                    t.push_back(y);</span><br><span class="line">                    attack.push_back(t);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> attack;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode785判断二分图</title>
    <url>/2020/11/21/leetcode785%E5%88%A4%E6%96%AD%E4%BA%8C%E5%88%86%E5%9B%BE/</url>
    <content><![CDATA[<p>这道题可以用dfs、bfs，并查集都可以做，下面的代码用是并查集实现的</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(graph.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++) root[i] =i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(graph[i].<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="built_in">find</span>(root,i);</span><br><span class="line">            <span class="keyword">int</span> q = <span class="built_in">find</span>(root,graph[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">1</span>;j&lt;graph[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> r = <span class="built_in">find</span>(root,graph[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(r==p) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> root[graph[i][j]] = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root[i]==i? i:<span class="built_in">find</span>(root, root[i]);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>leetcode547朋友圈</title>
    <url>/2020/11/21/leetcode547%E6%9C%8B%E5%8F%8B%E5%9C%88/</url>
    <content><![CDATA[<p>可以用bfs、dfs、和并查集，下面我们用并查集来做，注意：每合并一次朋友圈的数量减1</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(M.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = M.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(M.<span class="built_in">size</span>())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++) root[i] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;M.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;M.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(M[i][j]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> rj = <span class="built_in">find</span>(root,j);</span><br><span class="line">                <span class="keyword">int</span> ri = <span class="built_in">find</span>(root,i);</span><br><span class="line">                <span class="keyword">if</span>(rj!=ri)&#123;</span><br><span class="line">                    res--;</span><br><span class="line">                    root[rj] = ri;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root[i]==i?i:<span class="built_in">find</span>(root,root[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>并查集优化技巧,查询时缩短深度<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != root[i]) &#123;</span><br><span class="line">            root[i] = root[root[i]];</span><br><span class="line">            i = root[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode863距离为K的所有二叉树节点</title>
    <url>/2020/11/21/leetcode863%E8%B7%9D%E7%A6%BB%E4%B8%BAK%E7%9A%84%E6%89%80%E6%9C%89%E4%BA%8C%E5%8F%89%E6%A0%91%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<p>需要熟悉二叉树中的距离概念，这道题可以作为一道很好的递归、回溯练习题。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">distanceK</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> res;</span><br><span class="line">        core(root,target,K,res);</span><br><span class="line">        <span class="comment">// cout&lt;&lt; "****"&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">core</span><span class="params">(TreeNode* root, TreeNode* target, <span class="keyword">int</span> K,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target-&gt;val)&#123;</span><br><span class="line">            downwardK(target,K,nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">find</span>(root-&gt;right,target)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="built_in">find</span>(root-&gt;left,target)+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"rd: "&lt;&lt; rd &lt;&lt; " ld: "&lt;&lt; ld &lt;&lt;" K: "&lt;&lt;K&lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">if</span>(rd==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(K==ld)&#123;</span><br><span class="line">                nums.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            downwardK(root-&gt;right,K-ld<span class="number">-1</span>,nums);</span><br><span class="line">            core(root-&gt;left,target,K,nums);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ld==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(K==rd)&#123;</span><br><span class="line">                nums.push_back(root-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">            downwardK(root-&gt;left,K-rd<span class="number">-1</span>,nums);</span><br><span class="line">            core(root-&gt;right,target,K,nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">downwardK</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span> || k&lt;<span class="number">0</span> ) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"root "&lt;&lt; root-&gt;val &lt;&lt; "k: "&lt;&lt;k&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span>)&#123;</span><br><span class="line">            nums.push_back(root-&gt;val);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        downwardK(root-&gt;left,k<span class="number">-1</span>,nums);</span><br><span class="line">        downwardK(root-&gt;right,k<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(TreeNode* root, TreeNode* target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val==target-&gt;val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> rd = <span class="built_in">find</span>(root-&gt;right,target);</span><br><span class="line">        <span class="keyword">int</span> ld = <span class="built_in">find</span>(root-&gt;left,target);</span><br><span class="line">        <span class="keyword">if</span>(rd!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> rd+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ld!=<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ld+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode777交换LR字符串</title>
    <url>/2020/11/21/leetcode777%E4%BA%A4%E6%8D%A2LR%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>看懂题目之后很好理解，变换中L只能往左移动，R只能往右移动，因此用双指针就可以了。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">canTransform</span><span class="params">(<span class="built_in">string</span> start, <span class="built_in">string</span> <span class="built_in">end</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start.<span class="built_in">size</span>()!=<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// cout&lt;&lt;"i: "&lt;&lt;i&lt;&lt;" j:"&lt;&lt;j&lt;&lt;endl;</span></span><br><span class="line">            <span class="keyword">while</span>(i&lt;start.<span class="built_in">size</span>()&amp;&amp;start[i]==<span class="string">'X'</span>) i++;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;<span class="built_in">end</span>.<span class="built_in">size</span>()&amp;&amp;<span class="built_in">end</span>[j]==<span class="string">'X'</span>) j++;</span><br><span class="line">            <span class="keyword">if</span>(i==start.<span class="built_in">size</span>()||j==<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(start[i]!=<span class="built_in">end</span>[j]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start[i]==<span class="string">'R'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&lt;=j)&#123; </span><br><span class="line">                    i++;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(start[i]==<span class="string">'L'</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i&gt;=j)&#123;</span><br><span class="line">                   i++;</span><br><span class="line">                   j++;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==start.<span class="built_in">size</span>()&amp;&amp;j==<span class="built_in">end</span>.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode477全部汉明距离</title>
    <url>/2020/11/22/leetcode477%E5%85%A8%E9%83%A8%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/</url>
    <content><![CDATA[<p>分别统计每一位上0，1的个数，这一位产生的汉明距离就是二者的乘积</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> <span class="built_in">bit</span> = <span class="number">32</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="built_in">bit</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt_0 = <span class="number">0</span>, cnt_1 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[j];</span><br><span class="line">                <span class="keyword">if</span> (num &amp; ( <span class="number">1</span> &lt;&lt; i ))&#123;</span><br><span class="line">                    cnt_1++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    cnt_0++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += cnt_0*cnt_1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode494目标总和</title>
    <url>/2020/11/22/leetcode494%E7%9B%AE%E6%A0%87%E6%80%BB%E5%92%8C/</url>
    <content><![CDATA[<p>动态规划</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(S)&gt;<span class="number">1000</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">2001</span>]&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>+<span class="number">1000</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2001</span>;j++)&#123;</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="built_in">min</span>(j+nums[i],<span class="number">2000</span>)] += dp[i][j];</span><br><span class="line">                dp[i+<span class="number">1</span>][<span class="built_in">max</span>(j-nums[i],<span class="number">0</span>)] += dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()][S+<span class="number">1000</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode210课程调度2</title>
    <url>/2020/11/22/leetcode210%E8%AF%BE%E7%A8%8B%E8%B0%83%E5%BA%A62/</url>
    <content><![CDATA[<p>这道题其实就是拓补排序，拓补排序可以用dfs做，也可以用入度优先队列来做,注意检测是否存在环。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">in_stack</span><span class="params">(numCourses,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(numCourses,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; prerequisites.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            adj[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numCourses;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(in_stack,adj,i,s,visited)) <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())&#123;</span><br><span class="line">            res.push_back(s.top());</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; in_stack,<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; adj,<span class="keyword">int</span> node,<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt;&amp; s,<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[node]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(in_stack[node]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        in_stack[node] =  <span class="literal">true</span>;</span><br><span class="line">        visited[node] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; adj[node].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(in_stack,adj,adj[node][i],s,visited))&#123;</span><br><span class="line">                visited[node] = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.push(node);</span><br><span class="line">        visited[node] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode886分两组</title>
    <url>/2020/11/22/leetcode886%E5%88%86%E4%B8%A4%E7%BB%84/</url>
    <content><![CDATA[<p>和是否二分图那道题一样的做法，要注意图需要初始化为无向图。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">adj</span><span class="params">(N,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(N,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dislikes.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            adj[dislikes[i][<span class="number">0</span>]<span class="number">-1</span>].push_back(dislikes[i][<span class="number">1</span>]<span class="number">-1</span>);</span><br><span class="line">            adj[dislikes[i][<span class="number">1</span>]<span class="number">-1</span>].push_back(dislikes[i][<span class="number">0</span>]<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> p = <span class="built_in">find</span>(root,i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;adj[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> q = <span class="built_in">find</span>(root,adj[i][j]);</span><br><span class="line">                <span class="keyword">int</span> r = <span class="built_in">find</span>(root,adj[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">// cout&lt;&lt;"p: "&lt;&lt; p &lt;&lt; " q: " &lt;&lt; q &lt;&lt;" r: "&lt;&lt; r &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    root[q] = r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// cout&lt;&lt;"****"&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; root,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root[i]!=i)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = <span class="built_in">find</span>(root,root[i]);</span><br><span class="line">            root[i] = r;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>《视觉slam14讲》习题整理</title>
    <url>/2020/11/08/%E3%80%8A%E8%A7%86%E8%A7%89slam14%E8%AE%B2%E3%80%8B%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h4><span id="你知道c11标准吗你听说过或者使用过其中的那些特性有没有其他标准">你知道C++11标准吗？你听说过或者使用过其中的那些特性？有没有其他标准？</span></h4><p><a href="https://cloud.tencent.com/developer/article/1745592#:~:text=%E5%85%B3%E4%BA%8EC%2B%2B11%E6%96%B0,%E6%8E%A8%E5%AF%BC%E5%87%BA%E5%8F%98%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B%E3%80%82" target="_blank" rel="noopener">C++11新特性</a><br>内容比较多，这要关注一下几点</p>
<h5><span id="类型推导">类型推导</span></h5><p>auto和decltype关键字的引入，在编译时期推导出变量类型</p>
<h5><span id="右值引用">右值引用</span></h5><p><a href="https://bbs.huaweicloud.com/blogs/267038" target="_blank" rel="noopener">一文搞懂引用、指针、const、参数传递的关系</a></p>
<p>关于<code>绑定</code>的概念</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>称为<code>把a绑定到1</code></p>
<p><a href="https://zhuanlan.zhihu.com/p/335994370" target="_blank" rel="noopener">一文读懂C++右值引用和std::move</a><br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> &amp;&amp;ref_a_right = <span class="number">5</span>; <span class="comment">// ok</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>&amp; a = ref_a_right;</span><br><span class="line"> </span><br><span class="line">    ref_a_right = <span class="number">6</span>; <span class="comment">// 右值引用的用途：可以修改右值</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>输出<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><br>右值指向左值用<code>std::move</code></p>
<h5><span id="列表初始化">列表初始化</span></h5><p><a href="https://blog.csdn.net/hailong0715/article/details/54018002" target="_blank" rel="noopener">c++11 列表初始化</a> c++98/03只支持普通数组和POD初始化，现在支持类的列表初始化</p>
<h5><span id="stdfunction-和lambda表达式"></span></h5><p>std::function 是可调用对象，可以存储</p>
<ol>
<li>自由函数</li>
<li>lambda表达式，<code>[capture list] (params list) mutable exception-&gt; return type { function body }</code>，捕获变量的规则。</li>
<li>存储bind调用结果，可调用对象和参数绑定，延迟调用</li>
<li>其他函数调用</li>
</ol>
<h5><span id="智能指针"></span></h5><ol>
<li><code>shared_ptr&lt;T&gt;</code> 和 <code>make_shared&lt;T&gt;</code></li>
<li><code>unique_ptr&lt;T&gt;</code></li>
<li><code>week_ptr&lt;T&gt;</code></li>
</ol>
<h4><span id="如何在ubuntu中安装软件这些软件被安装在什么地方如果只知道模糊的软件名称如何安装它">如何在Ubuntu中安装软件？这些软件被安装在什么地方？如果只知道模糊的软件名称，如何安装它？</span></h4><p><code>apt-cache search keyword</code></p>
<h4><span id="阅读文献1和14你能看懂其中的内容吗">阅读文献【1】和【14】，你能看懂其中的内容吗？</span></h4><h4><span id="g的命令有哪些怎么填写参数可以更改生成的程序文件名">g++的命令有哪些？怎么填写参数可以更改生成的程序文件名？</span></h4><p><code>-c</code> 编译</p>
<p><code>-Ldir</code> 链接搜索库的路径</p>
<p><code>-static</code> 禁止使用动态库</p>
<p><code>-O[0,1,2,3]</code> -O0表示没有优化,-O1为缺省值，-O3优化级别最高</p>
<p><code>-llibrary</code> 制定编译的时候使用的库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -O output</span><br></pre></td></tr></table></figure>
<h4><span id="验证四元数旋转某个点后结果是个虚四元数所仍然对应到一个三维空间点">验证四元数旋转某个点后，结果是个虚四元数，所仍然对应到一个三维空间点</span></h4><p>四元数的共轭$q^<em>=(s,-v_q)$<br>四元数的逆 $q^{-1}=q^</em>/||q^*||$<br>单位四元数旋转某个点的公式：$p’=qpq^{-1}$，</p>
<h4><span id="画表总结旋转矩阵-轴角-欧拉角-四元数的转换关系">画表总结旋转矩阵、轴角、欧拉角、四元数的转换关系</span></h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>旋转矩阵</th>
<th>轴角</th>
<th>欧拉角</th>
<th>四元数</th>
</tr>
</thead>
<tbody>
<tr>
<td>旋转矩阵</td>
<td>-</td>
<td>罗德里格斯公式两边求迹</td>
<td></td>
<td></td>
</tr>
<tr>
<td>轴角</td>
<td>$R=\cos{\theta}\mathbf{I}+(1-\cos{\theta})\mathbf{n}\mathbf{n}^T)+\sin{\theta}\mathbf{n}^{\wedge}$</td>
<td>-</td>
<td></td>
<td></td>
</tr>
<tr>
<td>欧拉角</td>
<td>矩阵连乘</td>
<td></td>
<td>-</td>
<td></td>
</tr>
<tr>
<td>四元数</td>
<td>$R=\mathcal{v}\mathcal{v}^T+s^2I+2sv^{\wedge}+(v^{\wedge})^2$</td>
<td>左式求迹</td>
<td></td>
<td>-</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://zhuanlan.zhihu.com/p/45404840" target="_blank" rel="noopener">三维旋转：欧拉角、四元数、旋转矩阵、轴角之间的转换</a></p>
<h4><span id="有个大的eigen矩阵想把它左上角3x3的块取出来赋值为i_3times3编程实现">有个大的Eigen矩阵，想把它左上角3x3的块取出来赋值为$I_{3\times3}$,编程实现</span></h4><p>关键的类MatrixXd,MatrixXf，成员方法block，类方法Random，Identity<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;Eigen/Core&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    MatrixXd m=MatrixXd::Random(<span class="number">9</span>,<span class="number">9</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"before assign"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    m.block(<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">3</span>) = Matrix3d::Identity();</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"after assign"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;m&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4><span id="axb求解有几种方法在eigen里实现">AX=b求解有几种方法？在Eigen里实现</span></h4><ul>
<li>QR分解，LU分解</li>
<li>SVD分解的优点</li>
<li>理解广义逆求解</li>
<li>理解SVD求解推导</li>
</ul>
<h4><span id="验证so3se3sim3关于乘法成群">验证SO(3),SE(3),Sim(3)关于乘法成群</span></h4><h4><span id="验证r3rtimes构成李代数">验证$(R^3,R,\times)$构成李代数</span></h4><h4><span id="验证so3-和se3-满足李代数要求的性质">验证$so(3)$ 和$se(3)$ 满足李代数要求的性质</span></h4><h4><span id="为什么高斯牛顿方法的增量方程可能不正定不正定有什么几何含义为什么在这种情况下解不稳定">为什么高斯牛顿方法的增量方程可能不正定？不正定有什么几何含义？为什么在这种情况下解不稳定？</span></h4><h4><span id="orb-sift-surf的原理-对比和orb之间的优劣">ORB、SIFT、SURF的原理。对比和ORB之间的优劣</span></h4><h4><span id="设计程序调用opencv其他种类的特征点统计1000个特征点在你的机器上所用的时间">设计程序调用OpenCV其他种类的特征点，统计1000个特征点在你的机器上所用的时间。</span></h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core/core.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/features2d/features2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/xfeatures2d.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_usage</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"usage: [executable] [sift|orb] num_features path_to_image"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">imageTest</span><span class="params">(cv::Mat&amp; <span class="built_in">image</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"width:"</span>&lt;&lt;<span class="built_in">image</span>.cols&lt;&lt;<span class="string">" height:"</span>&lt;&lt;<span class="built_in">image</span>.rows&lt;&lt;<span class="string">" channels:"</span>&lt;&lt;<span class="built_in">image</span>.channels()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"image"</span>,<span class="built_in">image</span>);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> y = <span class="number">0</span>; y &lt; <span class="built_in">image</span>.rows; y++)&#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span>* row_ptr = <span class="built_in">image</span>.ptr&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(y);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> x = <span class="number">0</span>; x &lt; <span class="built_in">image</span>.cols; x++)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span>* data_ptr = &amp;row_ptr[x*<span class="built_in">image</span>.channels()];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> c = <span class="number">0</span>; c &lt; <span class="built_in">image</span>.channels(); c++)&#123;</span><br><span class="line">                <span class="keyword">unsigned</span> <span class="keyword">char</span> data = data_ptr[c];</span><br><span class="line">                <span class="keyword">if</span>(c==<span class="number">0</span>)&#123;</span><br><span class="line">                    data_ptr[c] = <span class="built_in">min</span>(data_ptr[c]+<span class="number">100</span>,<span class="number">255</span>) ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::duration&lt;<span class="keyword">double</span>&gt; timeCost = chrono::duration_cast&lt;chrono::duration&lt;<span class="keyword">double</span>&gt;&gt;(t2-t1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"time cost: "</span>&lt;&lt;timeCost.count()&lt;&lt;<span class="string">"seconds"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"image"</span>,<span class="built_in">image</span>);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat maskedImage = <span class="built_in">image</span>;</span><br><span class="line">    maskedImage(cv::Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)).setTo(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"masked image"</span>,<span class="built_in">image</span>);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    cv::Mat imageClone = <span class="built_in">image</span>.clone();</span><br><span class="line">    imageClone(cv::Rect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)).setTo(<span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    cv::imshow(<span class="string">"image"</span>,<span class="built_in">image</span>);</span><br><span class="line">    cv::imshow(<span class="string">"image clone"</span>,imageClone);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getDetector</span><span class="params">(cv::Ptr&lt;cv::FeatureDetector&gt;&amp; detector,cv::Ptr&lt;cv::DescriptorExtractor&gt;&amp; extractor,<span class="built_in">string</span> name,<span class="keyword">int</span> num_feature)</span></span>&#123;</span><br><span class="line">    transform(name.<span class="built_in">begin</span>(),name.<span class="built_in">end</span>(),name.<span class="built_in">begin</span>(),::<span class="built_in">toupper</span>);</span><br><span class="line">    <span class="keyword">if</span>(name==<span class="string">"ORB"</span>)&#123;</span><br><span class="line">        detector = cv::ORB::create(num_feature);</span><br><span class="line">        extractor = cv::ORB::create(num_feature);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(name==<span class="string">"SIFT"</span>)&#123;</span><br><span class="line">        detector = cv::SIFT::create(num_feature);</span><br><span class="line">        extractor = cv::SIFT::create(num_feature);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (name==<span class="string">"SURF"</span>)&#123;</span><br><span class="line">       detector = cv::xfeatures2d::SURF::create();</span><br><span class="line">       extractor = cv::xfeatures2d::SURF::create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> oss;</span><br><span class="line">        oss&lt;&lt;<span class="string">"not supported feature "</span>&lt;&lt; name &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">throw</span> invalid_argument(oss.str());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">featureExtraction</span><span class="params">(cv::Mat&amp; <span class="built_in">image</span>,<span class="built_in">string</span> algo,<span class="keyword">int</span> num_features)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;cv::KeyPoint&gt; keyPoints;</span><br><span class="line">    cv::Mat descriptors;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::Ptr&lt;cv::FeatureDetector&gt; detector;</span><br><span class="line">    cv::Ptr&lt;cv::DescriptorExtractor&gt; descriptor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    getDetector(detector,descriptor,algo,num_features);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t1 = chrono::steady_clock::now();</span><br><span class="line">    detector-&gt;detect(<span class="built_in">image</span>,keyPoints);</span><br><span class="line"></span><br><span class="line">    descriptor-&gt;compute(<span class="built_in">image</span>,keyPoints,descriptors);</span><br><span class="line"></span><br><span class="line">    chrono::steady_clock::time_point t2 = chrono::steady_clock::now();</span><br><span class="line">    chrono::milliseconds timeCost = chrono::duration_cast&lt;chrono::milliseconds&gt;(t2-t1);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"time cost:"</span>&lt;&lt;timeCost.count()&lt;&lt;<span class="string">"ms"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv::Mat detectOutput;</span><br><span class="line">    cv::drawKeypoints(<span class="built_in">image</span>,keyPoints,detectOutput,cv::Scalar::all(<span class="number">-1</span>),cv::DrawMatchesFlags::<span class="literal">DEFAULT</span>);</span><br><span class="line">    cv::imshow(<span class="string">"detect result"</span>,detectOutput);</span><br><span class="line">    cv::waitKey(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"key point size:"</span>&lt;&lt;keyPoints.<span class="built_in">size</span>()&lt;&lt;<span class="string">" descriptor size"</span>&lt;&lt;descriptors.<span class="built_in">size</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">4</span>)&#123;</span><br><span class="line">        print_usage();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* algo = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> num_features = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* file = argv[<span class="number">3</span>];</span><br><span class="line">    cv::Mat <span class="built_in">image</span>;</span><br><span class="line">    <span class="built_in">image</span> = cv::imread(file);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">image</span>.data==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">cerr</span>&lt;&lt;<span class="string">"文件"</span>&lt;&lt;file&lt;&lt;<span class="string">"不存在"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// imageTest(image);</span></span><br><span class="line"></span><br><span class="line">    featureExtraction(<span class="built_in">image</span>,algo,num_features);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4><span id="研究flann为何能快速处理匹配问题-出乱flann还有哪些快速匹配的手段">研究FLANN为何能快速处理匹配问题。出乱FLANN，还有哪些快速匹配的手段</span></h4><h4><span id="把演示程序所用的epnp改成其他pnp方法并研究他们的工作原理">把演示程序所用的EPnP改成其他PnP方法，并研究他们的工作原理</span></h4><a id="more"></a>]]></content>
      <tags>
        <tag>CV</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode转化为全零矩阵的最少反转次数</title>
    <url>/2021/12/14/leetcode%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%85%A8%E9%9B%B6%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%80%E5%B0%91%E5%8F%8D%E8%BD%AC%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h4><span id="bfs-状态压缩">BFS + 状态压缩</span></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">private:</span><br><span class="line">    static constexpr int  dirs[5][2] &#x3D;&#123;&#123;0,1&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;,&#123;1,0&#125;,&#123;0,0&#125;&#125;;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line">    int encode(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        int state&#x3D;0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;mat.size();i++)&#123;</span><br><span class="line">            for(int j&#x3D;0;j&lt;mat[i].size();j++)&#123;</span><br><span class="line">                state&lt;&lt;&#x3D;1;</span><br><span class="line">                state +&#x3D; mat[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int encode_mask(int row,int col,int m,int n)&#123;</span><br><span class="line">        int pos &#x3D; m*n-(row*n+col+1);</span><br><span class="line">        return 1&lt;&lt;pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int convert(int state,int row,int col,int m,int n)&#123;</span><br><span class="line">        for(int k&#x3D;0;k&lt;5;k++)&#123;</span><br><span class="line">            int r0&#x3D;row+dirs[k][0],c0&#x3D;col+dirs[k][1];</span><br><span class="line">            if (r0&gt;&#x3D;0 &amp;&amp; r0&lt;m &amp;&amp; c0&gt;&#x3D;0 &amp;&amp; c0&lt;n)&#123;</span><br><span class="line">                int mask &#x3D; encode_mask(r0,c0,m,n);</span><br><span class="line">                state ^&#x3D; mask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    void printState(int state)&#123;</span><br><span class="line">        std::bitset&lt;4&gt; s(state);</span><br><span class="line">        cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int minFlips(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        int init_state &#x3D; encode(mat);</span><br><span class="line">        if(init_state&#x3D;&#x3D;0) return 0;</span><br><span class="line">        unordered_set&lt;int&gt; seen;</span><br><span class="line">        queue&lt;int&gt; q;</span><br><span class="line">        q.push(init_state);</span><br><span class="line">        seen.insert(init_state);</span><br><span class="line">        int m &#x3D; mat.size();</span><br><span class="line">        int n &#x3D; mat[0].size();</span><br><span class="line">        int step&#x3D;0;</span><br><span class="line">        while(!q.empty())&#123;</span><br><span class="line">            ++step;</span><br><span class="line">            int k&#x3D;q.size();</span><br><span class="line">            for(int _&#x3D;0;_&lt;k;_++)&#123;</span><br><span class="line">                int state0 &#x3D; q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                for(int i&#x3D;0;i&lt;m;i++)&#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;n;j++)&#123;</span><br><span class="line">                        int state1 &#x3D; convert(state0,i,j,m,n);</span><br><span class="line">                        if(!seen.count(state1))&#123;</span><br><span class="line">                            seen.insert(state1);</span><br><span class="line">                            q.push(state1);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if(state1&#x3D;&#x3D;0)&#123;</span><br><span class="line">                            return step;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
</search>
